#include <stdio.h>
#include "track_data_new.h"
/*
struct track_edge {
  track_edge *reverse;
  track_node *src, *dest;
  int dist;              in millimetres
};

struct track_node {
  const char *name;
  node_type type;
  int num;               sensor or switch number
  track_node *reverse;   same location, but opposite direction
  track_edge edge[2];
};

*/
int Pathfind(int start, int end,
			 const struct track_node *track,
			 int prev[TRACK_MAX],
			 int distance[TRACK_MAX])
{
	int queue[TRACK_MAX]; // this is the queue of the tracks, the num is the index of the track which is stored in queue as a reference to the node

	int queue_size = 0;
	int queue_head = 0;
	int queue_tail = 0;

	for (int i = 0; i < TRACK_MAX; i++)
	{
		prev[i] = -1;
		distance[i] = 9999999;
	}
	distance[start] = 0;
	queue[queue_tail] = start; // start from one track node
	queue_tail++;
	queue_size++;
	// start from one track node
	while (queue_size > 0)
	{
		int current = queue[queue_head];
		printf("current = %d ", current);
		// print the name of the current track
		printf("name = %s ", track[current].name);
		queue_head++;
		queue_size--;
		//
		
		struct track_node *cur_node = &track[current];
		

		if (track[current].type == NODE_BRANCH)
		{
			struct track_edge *edge_straight = &cur_node->edge[DIR_STRAIGHT];
			struct track_edge *edge_curved = &cur_node->edge[DIR_CURVED];
			if (distance[edge_straight->dest->num] > distance[current] + edge_straight->dist)
			{
				// print next node and the number of the next node
				printf("next node = %s, num = %d\n", edge_straight->dest->name, edge_straight->dest->num);
				distance[edge_straight->dest->num] = distance[current] + edge_straight->dist;
				prev[edge_straight->dest->num] = current;
				queue[queue_tail] = edge_straight->dest->num;
				queue_tail++;
				queue_size++;
			}
			if (distance[edge_curved->dest->num] > distance[current] + edge_curved->dist)
			{
				// print next node and the number of the next node
				printf("next node = %s, num = %d\n", edge_curved->dest->name, edge_curved->dest->num);
				distance[edge_curved->dest->num] = distance[current] + edge_curved->dist;
				prev[edge_curved->dest->num] = current;
				queue[queue_tail] = edge_curved->dest->num;
				queue_tail++;
				queue_size++;
			}
			
		}else if (track[current].type != NODE_EXIT)
		{
			struct track_edge *edge_ahead = &cur_node->edge[DIR_AHEAD];
			if (distance[edge_ahead->dest->num] > distance[current] + edge_ahead->dist)
			{
				// print next node and the number of the next node
				printf("next node = %s, num = %d\n", edge_ahead->dest->name, edge_ahead->dest->num);
				distance[edge_ahead->dest->num] = distance[current] + edge_ahead->dist;
				prev[edge_ahead->dest->num] = current;
				queue[queue_tail] = edge_ahead->dest->num;
				queue_tail++;
				queue_size++;
			}
		}
		/*
		if (track[current].type == NODE_SENSOR)
		{
			struct track_node *reverse = track[current].reverse;
			// for reverse there is no distance. It is the same node.
			if (distance[reverse->num] > distance[current])
			{
				// print next node and the number of the next node
				printf("REVERSED next node = %s, num = %d\n", reverse->name, reverse->num);
				distance[reverse->num] = distance[current];
				prev[reverse->num] = current;
				queue[queue_tail] = reverse->num;
				queue_tail++;
				queue_size++;
			}
		}
		*/
	}
	return (distance[end]);
}

// path find returns the distance from the start to the end

int get_track_node_by_name(struct track_node *track, char *name)
{
	for (int i = 0; i < TRACK_MAX; i++)
	{
		if (0 == strcmp(track[i].name, name))
		{
			return i;
		}
	}
	return 0;
}
// Train functions Begin
int parse_path(struct track_node *track,
			   int start,
			   int end,
			   int distance[TRACK_MAX])
{
	int previouse_node[TRACK_MAX];
	Pathfind(start, end, track, previouse_node, distance);
	for (int i = 0; i < TRACK_MAX; i++)
	{
		// printf("distance[%d] = %d, previouse_node[%d] = %d\n", i, distance[i], i, previouse_node[i]);
	}
	int start_node = start;
	int end_node = end;
	// compute the path
	while (end_node != start_node)
	{
		//
		int prev_node = previouse_node[end_node];
		// printf("end_node = %d, prev_node = %d\n", end_node, prev_node);
		end_node = prev_node;
	}

	// print total distance

	return 0;
}

void solonoid(int id, char state)
{
	printf("solonoid id = %d, state = %c\n", id, state);
}

#define n 7
int main_test_reminant_1()
{
	// initialize the track
	// track_node track[TRACK_MAX];
	// init_tracka(track);
	// give a list of array representing distance from the start to the end
	// generate 5 possitive integers
	int max_dist = 10;
	int distance[n] = {0, 1, 2, 3, 4, 8, max_dist};

	int dist_from_end = 5; // stopping distance
	int index = 0;
	int val = max_dist - dist_from_end;
	// what is the index such that distance[index] is the closest node to the end that is further than dist_from_end
	int l = 0, r = n - 1;
	while (l < r)
	{
		// the non overflow version of (l + r) / 2
		int m = l + (r - l) / 2;
		if (distance[m] > val)
		{

			r = m - 1;
		}
		else
		{
			index = m;
			l = m;
		}
	}
	// print l, r, m
	printf("The value of l is %d\n", l);
	printf("The value of r is %d\n", r);
	printf("The index is %d\n", index);
	printf("Distance from end is %d\n", max_dist - distance[r]);
	printf("Delay distance is %d\n", max_dist - distance[r] - dist_from_end);
}
int main_test_reminant()
{
	struct track_node track[TRACK_MAX];
	init_tracka(track);
	int start = get_track_node_by_name(track, "A1");
	int end = get_track_node_by_name(track, "A5");
	int distance[TRACK_MAX];
	parse_path(track, start, end, distance);
	return 0;
}
